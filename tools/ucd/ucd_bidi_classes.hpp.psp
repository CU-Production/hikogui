// This file was generated by generate_unicode_data.py

#pragma once

#include "../utility/module.hpp"
#include <cstdint>
#include <optional>

namespace hi {
inline namespace v1 {
namespace detail {

constexpr auto ucd_bidi_classes_chunk_size = $chunk_size$_uz;
constexpr auto ucd_bidi_classes_index_width = $index_width$_uz;
constexpr auto ucd_bidi_classes_indices_size = $indices_size$_uz;
constexpr auto ucd_bidi_class_width = $bidi_class_width$_uz;

static_assert(std::has_single_bit(ucd_bidi_classes_chunk_size));

constexpr uint8_t ucd_bidi_classes_indices_bytes[$len(indices_bytes)$] = {\
$for i, x in enumerate(indices_bytes):
    $if i % 32 == 0:

   \
    $end
$"{:3},".format(x)$
$end

};

constexpr uint8_t ucd_bidi_classes_bytes[$len(bidi_classes_bytes)$] = {\
$for i, x in enumerate(bidi_classes_bytes):
    $if i % 32 == 0:

   \
    $end
$"{:3},".format(x)$
$end

};


} // namespace detail

/** Bidirectional class
 * Unicode Standard Annex #9: https://unicode.org/reports/tr9/
 */
enum class unicode_bidi_class : uint8_t {
    unknown = 0,
    L = 1, ///< Left-to-Right
    R = 2, ///< Right-to-Left
    AL = 3, ///< Right-to-Left Arabic
    EN = 4, ///< European Number
    ES = 5, ///< European Number Separator
    ET = 6, ///< European Number Terminator
    AN = 7, ///< Arabic Number
    CS = 8, ///< Common Number Separator
    NSM = 9, ///< Nonspacing Mark
    BN = 10, ///< Boundary Neutral
    B = 11, ///< Paragraph Separator
    S = 12, ///< Segment Separator
    WS = 13, ///< Whitespace
    ON = 14, ///< Other Neutrals
    // Explicit values.
    LRE = 15, ///< Left-to-Right Embedding
    LRO = 16, ///< Left-to-Right Override
    RLE = 17, ///< Right-to-Left Embedding
    RLO = 18, ///< Right-to-left Override
    PDF = 19, ///< Pop Directional Format
    LRI = 20, ///< Left-to-Right Isolate
    RLI = 21, ///< Right-to-Left Isolate
    FSI = 22, ///< First Strong Isolate
    PDI = 23 ///< Pop Directional Isolate
};

[[nodiscard]] constexpr bool is_isolate_starter(unicode_bidi_class const &rhs) noexcept
{
    using enum unicode_bidi_class;
    return rhs == LRI || rhs == RLI || rhs == FSI;
}

[[nodiscard]] constexpr bool is_isolate_formatter(unicode_bidi_class const &rhs) noexcept
{
    using enum unicode_bidi_class;
    return is_isolate_starter(rhs) || rhs == PDI;
}

[[nodiscard]] constexpr bool is_NI(unicode_bidi_class const &rhs) noexcept
{
    using enum unicode_bidi_class;
    return rhs == B || rhs == S || rhs == WS || rhs == ON || rhs == FSI || rhs == LRI || rhs == RLI || rhs == PDI;
}

[[nodiscard]] constexpr bool is_control(unicode_bidi_class const &rhs) noexcept
{
    using enum unicode_bidi_class;
    return rhs == RLE or rhs == LRE or rhs == RLO or rhs == LRO or rhs == PDF or rhs == BN;
}

[[nodiscard]] constexpr unicode_bidi_class unicode_bidi_class_from_string(std::string_view str) noexcept
{
    using enum unicode_bidi_class;

    if (str == "L") {
        return L;
    } else if (str == "R") {
        return R;
    } else if (str == "AL") {
        return AL;
    } else if (str == "EN") {
        return EN;
    } else if (str == "ES") {
        return ES;
    } else if (str == "ET") {
        return ET;
    } else if (str == "AN") {
        return AN;
    } else if (str == "CS") {
        return CS;
    } else if (str == "NSM") {
        return NSM;
    } else if (str == "BN") {
        return BN;
    } else if (str == "B") {
        return B;
    } else if (str == "S") {
        return S;
    } else if (str == "WS") {
        return WS;
    } else if (str == "ON") {
        return ON;
    } else if (str == "LRE") {
        return LRE;
    } else if (str == "LRO") {
        return LRO;
    } else if (str == "RLE") {
        return RLE;
    } else if (str == "RLO") {
        return RLO;
    } else if (str == "PDF") {
        return PDF;
    } else if (str == "LRI") {
        return LRI;
    } else if (str == "RLI") {
        return RLI;
    } else if (str == "FSI") {
        return FSI;
    } else if (str == "PDI") {
        return PDI;
    } else {
        hi_no_default();
    }
}

[[nodiscard]] constexpr unicode_bidi_class ucd_get_bidi_class(char32_t code_point) noexcept
{
    constexpr auto max_code_point_hi = detail::ucd_bidi_classes_indices_size - 1;

    auto code_point_hi = code_point / detail::ucd_bidi_classes_chunk_size;
    hilet code_point_lo = code_point % detail::ucd_bidi_classes_chunk_size;

    if (code_point_hi > max_code_point_hi) {
        code_point_hi = max_code_point_hi;
    }

    hilet chunk_index = load_bits_be<detail::ucd_bidi_classes_index_width>(
        detail::ucd_bidi_classes_indices_bytes,
        code_point_hi * detail::ucd_bidi_classes_index_width);

    // Add back in the lower-bits of the code-point.
    hilet index = (chunk_index * detail::ucd_bidi_classes_chunk_size) + code_point_lo;

    // Get the canonical combining class from the table.
    hilet value = load_bits_be<detail::ucd_bidi_class_width>(
        detail::ucd_bidi_classes_bytes, index * detail::ucd_bidi_class_width);

    return static_cast<unicode_bidi_class>(value);
}

}} // namespace hi::v1

